---
description: How to structure your Motia project
globs:
alwaysApply: true
---

# Architecture Guide

## Overview

This guide covers the architecture and best practices for structuring Motia projects.

**Key Takeaway**: Motia automatically discovers steps from anywhere in your project. Modern projects use `/src` for a familiar structure that works seamlessly with Domain-Driven Design.

## File Structure

Motia automatically discovers step files from your project. You can organize steps in either:

- **`/src` folder** (recommended) - Familiar pattern for most developers
- **`/steps` folder** - Traditional Motia pattern
- Both folders simultaneously

### Recommended Structure (using `/src`)

```
project/
├── src/
│   ├── api/           # API endpoints
│   │   ├── users.step.ts
│   │   └── orders.step.ts
│   ├── events/        # Event handlers
│   │   ├── order-processing.step.ts
│   │   └── notifications.step.ts
│   ├── cron/          # Scheduled tasks
│   │   └── cleanup.step.ts
│   ├── services/      # Business logic
│   ├── repositories/  # Data access
│   └── utils/         # Utilities
└── motia.config.ts
```

### Alternative Structure (using `/steps`)

```
project/
├── steps/
│   ├── api/
│   │   └── users.step.ts
│   ├── events/
│   │   └── order-processing.step.ts
│   └── cron/
│       └── cleanup.step.ts
├── src/
│   ├── services/
│   └── utils/
└── motia.config.ts
```

Create subfolders within your chosen directory to organize related steps into logical groups (domains, features, or flows).

**Why `/src` is recommended:**
- Familiar to developers from other frameworks (Next.js, NestJS, etc.)
- Natural co-location with services, repositories, and utilities
- Works seamlessly with Domain-Driven Design patterns
- Cleaner project root with fewer top-level folders

## Step Naming Conventions

### Typescript

- Use kebab-case for filenames: `resource-processing.step.ts`
- Include `.step` before language extension

### Python

- Use snake_case for filenames: `data_processor_step.py`
- Include `_step` before language extension

### Global

- Match handler names to config names
- Use descriptive, action-oriented names

## Code Style Guidelines

- **JavaScript**: Use modern ES6+ features, async/await, proper error handling
- **TypeScript**: Make sure you use the correct Handlers type that is auto generated on the `types.d.ts` file.

## Defining Middlewares

Middleware is a powerful feature in Motia for common validation, error handling, and shared logic.

### Middleware Organization

Store middlewares in a dedicated folder:
- `/middlewares` at project root (recommended)
- `/src/middlewares` if using `/src` structure

### Best Practices

- **One responsibility per middleware** - Follow SOLID principles
- **Descriptive naming** - Use names like `auth.middleware.ts`, `validation.middleware.ts`
- **Handle errors gracefully** - Use core middleware for ZodError (see [Error Handling Guide](./error-handling.mdc))
- **Avoid infrastructure concerns** - Rate limiting and CORS are handled by infrastructure, not middleware

## Domain Driven Design

Motia encourages Domain-Driven Design (DDD) principles for maintainable, scalable applications.

### Folder Structure for DDD

When using `/src` for steps (recommended), your structure naturally supports DDD:

```
src/
├── api/              # API Steps (Controllers)
├── events/           # Event Steps (Controllers)
├── cron/             # Cron Steps (Controllers)
├── services/         # Business logic layer
├── repositories/     # Data access layer
├── utils/            # Utility functions
└── types/            # Shared types (optional)
```

### Layer Responsibilities

- **Steps (Controller Layer)**: Handle validation, call services, emit events
- **Services**: Contain business logic, orchestrate repositories
- **Repositories**: Direct data access (database, external APIs)
- **Utils**: Pure utility functions with no side effects

### Best Practices

- Models and DTOs are not necessary - use Zod schemas from step configs
- Steps should focus on validation and calling services
- Avoid service methods that only call repositories - Steps can access repositories directly
- Keep business logic in services, not in steps

### Services

Services contain your business logic and should be organized by domain.

**Structure:**
```
src/
├── services/
│   ├── auth/
│   │   ├── index.ts       # Export service
│   │   ├── login.ts       # Login method
│   │   └── register.ts    # Register method
│   └── orders/
│       ├── index.ts
│       └── create-order.ts
└── api/
    └── auth.step.ts       # Uses authService
```

**Service Definition (`/src/services/auth/index.ts`):**
```typescript
/**
 * Business logic methods imported from separate files
 */
import { login } from './login'
import { register } from './register'

/**
 * Export service with methods as properties
 */
export const authService = {
  login,
  register
}
```

**Usage in Step (`/src/api/auth.step.ts`):**
```typescript
import { authService } from '../services/auth'

export const handler = async (req, ctx) => {
  const user = await authService.login(req.body.email, req.body.password)
  return { status: 200, body: { user } }
}
```

## Logging and observability

- Make sure to use the Logger from Motia (from context object) to log messages.
- Make sure to have visibility of what is going on in a request
- Before throwing errors, make sure to log the issue, identify if issue is a validation blocker, then log with `logger.warn`, if it's something that is not supposed to happen, then log with `logger.error`.
- Make sure to add context to the logs to help identify any potential issues.


