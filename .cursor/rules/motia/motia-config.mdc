---
description: Application configuration for Motia projects
globs: motia.config.ts,motia.config.js
alwaysApply: false
---
# Motia Configuration Guide

The `motia.config.ts` file is the central configuration file for your Motia application. It allows you to customize plugins, adapters, stream authentication, and Express app settings.

## Critical Requirement: package.json Must Use ES Modules

**All Motia projects MUST have `"type": "module"` in their `package.json`.**

Motia uses ES modules internally and requires this setting to function correctly. Without it, you may encounter import/export errors during runtime.

### Correct package.json Setup

```json
{
  "name": "my-motia-project",
  "description": "My Motia application",
  "type": "module",
  "scripts": {
    "postinstall": "motia install",
    "dev": "motia dev",
    "start": "motia start",
    "build": "motia build",
    "generate-types": "motia generate-types"
  }
}
```

### Migration from Existing Projects

If you have an existing Motia project, ensure you add `"type": "module"` to your `package.json`:

```json
{
  "name": "my-project",
  "type": "module",  // ← Add this line
  "scripts": {
    "dev": "motia dev"
  }
}
```

## Creating the Configuration File

Create a `motia.config.ts` file in the root of your project:

```typescript
import { config } from 'motia'

export default config({
  plugins: [],
  adapters: {},
  streamAuth: undefined,
  app: undefined,
})
```

## Creating Projects Without Embedded Redis

By default, Motia includes an embedded Redis binary for easy local development. However, if you prefer to use your own external Redis instance, you can use the `--skip-redis` flag when creating a new project:

```bash
npx motia create my-app --skip-redis
```

This flag:
- Skips the embedded Redis binary installation
- Creates a `motia.config.ts` pre-configured for external Redis connection
- Requires you to provide your own Redis instance before running Motia

When using `--skip-redis`, you'll need to ensure Redis is running and properly configured in your `motia.config.ts` file (see Redis Configuration section below).

## Type Definitions

```typescript
import type { Express } from 'express'

export type Config = {
  /**
   * Optional: Callback to customize the Express app instance.
   * Use this to add custom middleware, routes, or configurations.
   */
  app?: (app: Express) => void

  /**
   * Optional: Array of plugin builders to extend Motia functionality.
   * Plugins can add workbench UI components and custom steps.
   */
  plugins?: MotiaPluginBuilder[]

  /**
   * Optional: Custom adapters for state, events, cron, and streams.
   * Use this for horizontal scaling or custom storage backends.
   */
  adapters?: AdapterConfig

  /**
   * Optional: Stream authentication configuration.
   * Use this to secure real-time stream subscriptions.
   */
  streamAuth?: StreamAuthConfig

  /**
   * Optional: Redis configuration.
   * Configure Redis connection or use the built-in in-memory Redis server.
   */
  redis?: RedisConfig
}

export type AdapterConfig = {
  state?: StateAdapter
  streams?: StreamAdapterManager
  events?: EventAdapter
  cron?: CronAdapter
}

export type StreamAuthRequest = {
  headers: Record<string, string | string[] | undefined>
  url?: string
}

export type StreamAuthConfig<TSchema extends z.ZodTypeAny = z.ZodTypeAny> = {
  /**
   * JSON Schema defining the shape of the auth context.
   * Use z.toJSONSchema() to convert a Zod schema.
   */
  contextSchema: JsonSchema

  /**
   * Authentication callback that receives the request and returns
   * the auth context or null if authentication fails.
   */
  authenticate: (request: StreamAuthRequest) => Promise<z.infer<TSchema> | null> | (z.infer<TSchema> | null)
}

export type RedisConfig =
  | {
      useMemoryServer?: false
      host: string
      port: number
      password?: string
      username?: string
      db?: number
    }
  | {
      useMemoryServer: true
    }
```

## Plugins

Plugins extend Motia functionality by adding workbench UI components and custom steps.

### Plugin Type Definition

```typescript
export type WorkbenchPlugin = {
  packageName: string
  componentName?: string
  label?: string
  labelIcon?: string
  position?: 'bottom' | 'top'
  cssImports?: string[]
  props?: Record<string, any>
}

export type MotiaPlugin = {
  workbench: WorkbenchPlugin[]
  dirname?: string
  steps?: string[]
}

export type MotiaPluginBuilder = (motia: MotiaPluginContext) => MotiaPlugin
```

### Using Built-in Plugins

```typescript
import { config } from 'motia'

const statesPlugin = require('@motiadev/plugin-states/plugin')
const endpointPlugin = require('@motiadev/plugin-endpoint/plugin')
const logsPlugin = require('@motiadev/plugin-logs/plugin')
const observabilityPlugin = require('@motiadev/plugin-observability/plugin')

export default config({
  plugins: [observabilityPlugin, statesPlugin, endpointPlugin, logsPlugin],
})
```

### Creating a Local Plugin

**Project structure:**
```
project/
├── src/              # Steps can be in /src or /steps
│   └── api/
│       └── example.step.ts
├── plugins/
│   └── my-plugin/
│       ├── components/
│       │   └── my-plugin-panel.tsx
│       └── index.ts
└── motia.config.ts
```

**Plugin implementation (`plugins/my-plugin/index.ts`):**
```typescript
import path from 'node:path'
import { config, type MotiaPlugin, type MotiaPluginContext } from 'motia'

function myLocalPlugin(motia: MotiaPluginContext): MotiaPlugin {
  motia.registerApi(
    {
      method: 'GET',
      path: '/__motia/my-plugin',
    },
    async (_req, _ctx) => {
      return {
        status: 200,
        body: { message: 'Hello from my plugin!' },
      }
    },
  )

  return {
    dirname: path.join(__dirname, 'plugins'),
    steps: ['**/*.step.ts'],
    workbench: [
      {
        componentName: 'MyComponent',
        packageName: '~/plugins/components/my-component',
        label: 'My Plugin',
        position: 'top',
        labelIcon: 'toy-brick',
      },
    ],
  }
}

export default config({
  plugins: [myLocalPlugin],
})
```

### Common Plugin Errors

**Error: Component not found**
- **Cause**: `packageName` doesn't match the actual folder structure
- **Solution**: Ensure `packageName: '~/plugins/my-plugin'` matches `plugins/my-plugin/` folder

**Error: Plugin not loading in workbench**
- **Cause**: Plugin function not exported correctly
- **Solution**: Use `export default function` in plugin's `index.ts`

**Error: Module resolution failed**
- **Cause**: Using incorrect casing in folder/file names
- **Solution**: Use `kebab-case` for folders/files, `PascalCase` for React components

## Adapters

Adapters allow you to customize the underlying infrastructure for state management, event handling, cron jobs, and streams. This is useful for horizontal scaling or using custom storage backends.

### Available Adapter Packages

| Package | Description |
|---------|-------------|
| `@motiadev/adapter-redis-state` | Redis-based state management for distributed systems |
| `@motiadev/adapter-redis-cron` | Redis-based cron scheduling with distributed locking |
| `@motiadev/adapter-redis-streams` | Redis Streams for real-time data |
| `@motiadev/adapter-rabbitmq-events` | RabbitMQ for event messaging |
| `@motiadev/adapter-bullmq-events` | BullMQ for event queue processing |

### Using Custom Adapters

```typescript
import { config } from 'motia'
import { RedisStateAdapter } from '@motiadev/adapter-redis-state'
import { RabbitMQEventAdapter } from '@motiadev/adapter-rabbitmq-events'
import { RedisCronAdapter } from '@motiadev/adapter-redis-cron'

export default config({
  adapters: {
    state: new RedisStateAdapter(
      { url: process.env.REDIS_URL },
      { keyPrefix: 'myapp:state:', ttl: 3600 }
    ),
    events: new RabbitMQEventAdapter({
      url: process.env.RABBITMQ_URL!,
      exchangeType: 'topic',
      exchangeName: 'motia-events',
    }),
    cron: new RedisCronAdapter(
      { url: process.env.REDIS_URL },
      { keyPrefix: 'myapp:cron:', lockTTL: 30000 }
    ),
  },
})
```

## Stream Authentication

Stream authentication secures real-time stream subscriptions by validating client credentials.

### Configuration

```typescript
import { config, type StreamAuthRequest } from 'motia'
import { z } from 'zod'

const authContextSchema = z.object({
  userId: z.string(),
  permissions: z.array(z.string()).optional(),
})

export default config({
  streamAuth: {
    contextSchema: z.toJSONSchema(authContextSchema),
    authenticate: async (request: StreamAuthRequest) => {
      const token = extractToken(request)
      
      if (!token) {
        return null
      }

      const user = await validateToken(token)
      if (!user) {
        throw new Error('Invalid token')
      }

      return {
        userId: user.id,
        permissions: user.permissions,
      }
    },
  },
})

function extractToken(request: StreamAuthRequest): string | undefined {
  const protocol = request.headers['sec-websocket-protocol'] as string | undefined
  if (protocol?.includes('Authorization')) {
    const [, token] = protocol.split(',')
    return token?.trim()
  }

  if (request.url) {
    try {
      const url = new URL(request.url)
      return url.searchParams.get('authToken') ?? undefined
    } catch {
      return undefined
    }
  }

  return undefined
}
```

### Using Auth Context in Streams

Once configured, the auth context is available in the `canAccess` callback of stream configurations:

```typescript
import { StreamConfig } from 'motia'
import { z } from 'zod'

export const config: StreamConfig = {
  name: 'protectedStream',
  schema: z.object({ data: z.string() }),
  baseConfig: { storageType: 'default' },
  canAccess: (subscription, authContext) => {
    if (!authContext) return false
    return authContext.permissions?.includes('read:stream')
  },
}
```

## Express App Customization

Use the `app` callback to customize the Express application instance:

```typescript
import { config } from 'motia'
import cors from 'cors'
import helmet from 'helmet'

export default config({
  app: (app) => {
    app.use(helmet())
    app.use(cors({ origin: process.env.ALLOWED_ORIGINS?.split(',') }))
    
    app.get('/health', (_req, res) => {
      res.json({ status: 'healthy' })
    })
  },
})
```

## Redis Configuration

Motia uses Redis for state management, caching, and real-time features. By default, Motia automatically starts an in-memory Redis server for local development, eliminating the need for external Redis installation.

### Default Behavior (In-Memory Redis)

When no `redis` configuration is provided, Motia uses an embedded in-memory Redis server:

```typescript
import { config } from 'motia'

export default config({})
```

You can also explicitly enable the in-memory server:

```typescript
export default config({
  redis: {
    useMemoryServer: true,
  },
})
```

### Using External Redis

To connect to an external Redis instance (useful for production or when you already have Redis running), configure the connection settings:

```typescript
import { config } from 'motia'

export default config({
  redis: {
    useMemoryServer: false,
    host: 'localhost',
    port: 6379,
  },
})
```

For production environments with authentication:

```typescript
export default config({
  redis: {
    useMemoryServer: false,
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD,
    username: process.env.REDIS_USERNAME,
    db: parseInt(process.env.REDIS_DB || '0'),
  },
})
```

The optional Redis configuration fields include:
- `password`: Redis password for authentication
- `username`: Redis username (Redis 6.0+)
- `db`: Database number to select (default: 0)

You can also use environment variables directly:
- `MOTIA_REDIS_PASSWORD`: Redis password
- `MOTIA_REDIS_USERNAME`: Redis username
- `MOTIA_REDIS_DB`: Database number

### Creating Projects with External Redis

When creating a new project, you can skip the embedded Redis binary installation using the `--skip-redis` flag:

```bash
npx motia create my-app --skip-redis
```

This will create a project with `motia.config.ts` pre-configured for external Redis, and you'll need to ensure Redis is running before starting your application.

## Complete Example

```typescript
import path from 'node:path'
import { config, type MotiaPlugin, type MotiaPluginContext, type StreamAuthRequest } from 'motia'
import { z } from 'zod'

const statesPlugin = require('@motiadev/plugin-states/plugin')
const logsPlugin = require('@motiadev/plugin-logs/plugin')

const authContextSchema = z.object({
  userId: z.string(),
  role: z.enum(['admin', 'user']).optional(),
})

type AuthContext = z.infer<typeof authContextSchema>

const tokens: Record<string, AuthContext> = {
  'admin-token': { userId: 'admin-1', role: 'admin' },
  'user-token': { userId: 'user-1', role: 'user' },
}

function extractAuthToken(request: StreamAuthRequest): string | undefined {
  const protocol = request.headers['sec-websocket-protocol'] as string | undefined
  if (protocol?.includes('Authorization')) {
    const [, token] = protocol.split(',')
    return token?.trim()
  }

  if (request.url) {
    try {
      const url = new URL(request.url)
      return url.searchParams.get('authToken') ?? undefined
    } catch {
      return undefined
    }
  }

  return undefined
}

export default config({
  plugins: [statesPlugin, logsPlugin],
  streamAuth: {
    contextSchema: z.toJSONSchema(authContextSchema),
    authenticate: async (request: StreamAuthRequest) => {
      const token = extractAuthToken(request)
      if (!token) return null

      const context = tokens[token]
      if (!context) throw new Error(`Invalid token: ${token}`)

      return context
    },
  },
})
```
